[{"title":"Dictionary实现","date":"2022-12-12T13:12:31.000Z","url":"/2022/12/12/Dictionary%E5%AE%9E%E7%8E%B0/","tags":[["C#","/tags/C/"]],"categories":[["undefined",""]],"content":"目录[TOC] [^.netframework 原码地址：]: 无关第一次写文章，而这篇文章是我边看源码边写得，技术有限会有不对得地方，不过会尽最大能力去写。如有问题欢迎讨论 由这篇文章开启一条成为大佬之路吧，由简到难，先还是从最简单而我又很喜欢的C#开始,ing Hash算法1 什么是hash算法hash算法又称散列算法，目的是把二进制内容计算成有限字符串或数字随机组成的散列值 特点： 不同的二进制经过hash算法后的得到得散列值也有概率会相同，概率高低与算法好坏有关（续） 相同的二进制经过hash算法得到的散列值一定相同 散列值是不可逆的，能够被逆向得值都是编码或特俗加密内容（如web传输中的base64编码） 2.碰撞描述hash算法时有与算法好坏有关？ 那碰撞又是什么呢？ 就是二个不同的二进制组成的数据，被计算成了相同的hash值 好的算法 碰撞率更低，时间复杂度更高 坏的算法 碰撞率提高，时间复杂度更低 3.解决冲突方式1. 拉链法：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。 2. 再Hash法：得到hash值后再调用hash函数，直到解决冲突。 —Dictionary使用得就是拉链法，其它方法自行了解把— 文件传输如客户端上传了一个文件，对于服务端比较合理得做法就是，查找该文件是否已经保存在硬盘中了，如不存在就进行io写入 这时候就用到了该算法，转换为一定长度得字符或数字，这样文件就具有了可以标识得值，更快去配合sql查找，或在文件传输前使用hash记录下来，传输完成后次hash，去比较两次hash值判，来断传输中是不是文件被篡改过。可以采用MD5或SHA-1去实现，文件使用SHA-1 计算出来得散列值更不容易发生碰撞 md5更应该去加密不敏感的信息，可以配合原文+salt，或者进行多次hash提高安全性 .netframework中hash算法ValueType 类型要做为Dictionary的Key 要去重写GetHashCode()，Equals() 对象类型不重写 最后都会调用 object.InternalGetHashCode(this);来生成，该实现来自外部代码，通常由c++这种 如何去重写GetHashCode()？个人采用该类的属性，或者字段进行 xor 运算（减低碰撞发生概率，在字典中能快速查找就行) 为什么还要重写Equals()？使得hash碰撞时需要使用比较器 Dictionary好处查找时间复杂度接近于常量级别，相当于直接用数组下标拿出元素 可以对程序经常用到的数据进行使用，达到高速存取修改的目地 缺陷 数据量较多的字典在framework达到碰撞阈值或者数组扩容都会有性能影响， 最求性能极致也可以在初始化时指定构建合适大小的容量 Dictionary的继承结构为了方便把源码都贴过来,没有贴namespace都在System.Collections命名空间下 IDictionary ICollection IEnumerable IReadOnlyDictionary IReadOnlyCollection Sourceprivate struct private variable 第一次Insert进行第一次添加代码简化为 当创建字典时赋予初始字典大小，会在构造函数时调用 Initialize(int capacity) 假设本次没有给定字典初始大小 Initialize(int capacity) 会分别初始化4个entries hashcode &#x3D; -1，next &#x3D; -1 和 4个 buckets 默认值 -1 数组 操作过程假如第一次调用Add(9，12)，hashcode为10 1.通过对hashCode Mod 运算，计算出该元素落在哪一个buckets桶中。现在桶的长度（buckets.Length）为4，Mod操作9 % 4最后落在index为1的桶中，也就是&#96;buckets[1]。对于这一次添加，entries下标使用的是count 2..buckets赋值为index，buckets[1] &#x3D; 0; 3.version++ 与迭代器有关 结论 buckets存放的值是元素在entries数组里的下标，如果buckets取出的值为-1，则代表没有元素存放 碰撞处理在最理想情况下，当然想的是每个桶都有它对应的一个元素下标，而 int targetBucket &#x3D; hashCode % buckets.Length;这种运算会多次命中在一个桶上，比如再次Add(5,102) 5 mod 4 buckets[1] &#x3D; 1;原来得值将会被覆盖，这是不被希望得， 所以采用entries[index].next &#x3D; buckets[targetBucket] 多次命中在一个桶上就构建成了一个单向链表，next就记录了在同一个桶里上一次添加的元素下标，-1代表这是最后一个元素，而collisionCount变量记录命中在该hash桶上的元素数量 可以查看下面逻辑 添加时键已存在时会抛异常得 Resize 从Insert方法可以发现，代码段调用了2次Resize函数，其中一次是数组空间用尽，第二次是命中同一个桶的数量达到了阈值 第二次调用该函数会去使用另一种比较器，代码段中有微软开发者注释 IsPrime(int candidate) 函数该函数扩容和初始化字典时都会去调用， 对primes数组里值进行比较（为了让元素分配更分散，这些值或许是微软程序员认为合理的） 所以桶数组和结构体真正的数组大小是primes 里的值 Resize(int newSize, bool forceNewHashCodes)函数1第一次调用 对hash桶和链表数组(结构体数组)扩容，其中链表数组使用Array.Copy()进行值拷贝 而由于hash桶已经改变了长度，所以再次 mod 去计算命中的目标 2.第二次调用 本次没有去扩容数组。 由于改变了比较器的实现，再次hashcode 进行mod运算得到新的命中下标 这个方式是不确定的，最坏情况下会发生连续调用 GetValue索引器 TryGetValue 通过添加得源码，可以看出find操作也很简单，我就不继续啰嗦了 至于怎么取值看自己情况，一个会抛异常一个不会抛异常 （循环取值时不要尝试用try{}catch 去抓取索引器取值抛的异常……因为真的会影响性能 这与堆建立的异常跟踪有关） Remove Insert方法 同样很简单，没必要啰嗦 Version 异常下面代码会抛出一个 System.InvalidOperationException:“Collection was modified; enumeration operation may not execute.”异常 IL码这是上面代码的IL码，便于下面了解foreach原理 foreach官方是这样描述的 “如果 foreach 语句应用为 null，则会引发 NullReferenceException。 如果 foreach 语句的源集合为空，则 foreach 语句的正文不会被执行，而是被跳过” 自己的类怎么去使用foeach遍历，可以查看官方文档 首先调用对象的GetEnumerator()函数，这里会执行此构造方法，而这里Enumerator结构体的version被初始化 每一次循环都会一直调用MoveNext()函数，直到为false 在其中有这样一行 在源码都可以发现删除或者增加都会进行version++，如果在迭代时进行remove，add等操作，这时与迭代前的version值不相同 会抛出异常。这样设计也是合理得，在迭代时进行添加元素会导致各种各样的问题，在Java遍历集合中就有体现(使用了快照的方式)。 而.net的做法更加简洁 补充： 在高版本中 会有如await foreach 这是常用的异步编程，具体原理比较复杂，都是交给编译器去把异步代码变为普通代码的。 可以使用反编译工具自行查看。这时候要实现IAsyncEnumerable 接口方法"}]