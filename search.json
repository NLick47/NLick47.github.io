[{"title":"Dictionary实现","date":"2022-12-12T13:12:31.000Z","url":"/2022/12/12/Dictionary%E5%AE%9E%E7%8E%B0/","tags":[["水文章","/tags/%E6%B0%B4%E6%96%87%E7%AB%A0/"]],"categories":[["undefined",""]],"content":"目录[TOC] [^.netframework 原码地址：]: 无关第一次写文章，而这篇文章是我边看源码边写得，技术有限会有不对得地方，不过会尽最大能力去写。如有问题欢迎讨论 由这篇文章开启一条成为大佬之路吧，由简到难，先还是从最简单而我又很喜欢的C#开始,ing Hash算法1 概括hash算法又称散列算法，目的是把二进制内容计算成有限字符串或数字随机组成的散列值 特点： 不同的二进制经过hash算法后的得到得散列值也有概率会相同，概率高低与算法好坏有关（续） 相同的二进制经过hash算法得到的散列值一定相同 散列值是不可逆的，能够被逆向得值都是编码或特俗加密内容（如web传输中的base64编码） 2.碰撞描述hash算法时有与算法好坏有关？ 那碰撞又是什么呢？ 就是二个不同的二进制组成的数据，被计算成了相同的hash值 好的算法 碰撞率更低，时间复杂度更高 坏的算法 碰撞率提高，时间复杂度更低 3.解决冲突方式1. 拉链法：这种方法的思路是将产生冲突的元素建立一个单链表，并将头指针地址存储至Hash表对应桶的位置。这样定位到Hash表桶的位置后可通过遍历单链表的形式来查找元素。 2. 再Hash法：得到hash值后再调用hash函数，直到解决冲突。 —Dictionary使用得就是拉链法，其它方法自行了解把— 应用文件传输使用SHA-1去比较文件散列值判断服务端是否已存在该文件或者在是否在中途被篡改 加密如wifi密码，压缩密码等，只存储hash值 优化如unity修改状态机参数使用字符串的hash值 .netframeworkValueType 类型要做为Dictionary的Key 应该要去继承比较器接口重写 GetHashCode()，Equals() 对象类型不重写 最后都会调用 object.InternalGetHashCode(this);来生成，该实现来自外部代码 Dictionary好处查找时间复杂度接近于常量级别，相当于直接用数组下标拿出元素 可以对程序经常用到的数据进行使用，达到高速存取修改的目地 缺陷 数据量较多的字典在framework达到碰撞阈值或者数组扩容都会有性能影响， 最求性能极致也可以在初始化时指定构建合适大小的容量 Dictionary的继承结构为了方便把源码都贴过来,没有贴namespace都在System.Collections命名空间下 IDictionary ICollection IEnumerable IReadOnlyDictionary IReadOnlyCollection Sourceprivate struct private variable 第一次Insert进行第一次添加代码简化为 当创建字典时赋予初始字典大小，会在构造函数时调用 Initialize(int capacity) 假设本次没有给定字典初始大小 Initialize(int capacity) 会分别初始化4个entries hashcode &#x3D; -1，next &#x3D; -1 和 4个 buckets 默认值 -1 数组 操作过程假如第一次调用Add(9，12)，hashcode为10 1.通过对hashCode Mod 运算，计算出该元素落在哪一个buckets桶中。现在桶的长度（buckets.Length）为4，Mod操作9 % 4最后落在index为1的桶中，也就是&#96;buckets[1]。对于这一次添加，entries下标使用的是count 2..buckets赋值为index，buckets[1] &#x3D; 0; 3.version++ 与迭代器有关 结论 buckets存放的值是元素在entries数组里的下标，如果buckets取出的值为-1，则代表没有元素存放 碰撞处理在最理想情况下，当然想的是每个桶都有它对应的一个元素下标，而 int targetBucket &#x3D; hashCode % buckets.Length;这种运算会多次命中在一个桶上，比如再次Add(5,102) 5 mod 4 buckets[1] &#x3D; 1;原来得值将会被覆盖，这是不被希望得， 所以采用entries[index].next &#x3D; buckets[targetBucket] 多次命中在一个桶上就构建成了一个单向链表，next就记录了在同一个桶里上一次添加的元素下标，-1代表这是最后一个元素，而collisionCount变量记录命中在该hash桶上的元素数量 可以查看下面逻辑 添加时键已存在时会抛异常得 Resize 从Insert方法可以发现，代码段调用了2次Resize函数，其中一次是数组空间用尽，第二次是命中同一个桶的数量达到了阈值 第二次调用该函数会去使用另一种比较器，代码段中有微软开发者注释 IsPrime(int candidate) 函数该函数扩容和初始化字典时都会去调用， 扩容值使用primes 素数数组值。相对于其它自然数，素数更不容易落在一样的桶中 Resize(int newSize, bool forceNewHashCodes)函数1第一次调用 对hash桶和链表数组(结构体数组)扩容，其中链表数组使用Array.Copy()进行值拷贝 而由于hash桶已经改变了长度，所以再次 mod 去计算命中的目标 2.第二次调用 本次没有去扩容数组。 由于改变了比较器的实现，再次hashcode 进行mod运算得到新的命中下标 这个方式是不确定的，最坏情况下会发生连续调用 GetValue索引器 TryGetValue 理解add逻辑后，find操作不必要继续啰嗦 至于怎么取值看自己情况，一个会抛异常一个不会抛异常 （循环取值时不要尝试用try{}catch 去抓取索引器取值抛的异常……会影响性能 这与堆建立的异常跟踪有关） Remove Insert方法 同样很简单，没必要啰嗦 Version 异常下面代码会抛出一个 System.InvalidOperationException:“Collection was modified; enumeration operation may not execute.”异常 IL码这是上面代码的IL码，便于下面了解foreach原理 foreach官方是这样描述的 “如果 foreach 语句应用为 null，则会引发 NullReferenceException。 如果 foreach 语句的源集合为空，则 foreach 语句的正文不会被执行，而是被跳过” 自己的类怎么去使用foeach遍历，可以查看官方文档 首先调用对象的GetEnumerator()函数，这里会执行此构造方法，而这里Enumerator结构体的version被初始化 每一次循环都会一直调用MoveNext()函数，直到为false 在其中有这样一行 在源码都可以发现删除或者增加都会进行version++，如果在迭代时进行remove，add等操作，这时与迭代前的version值不相同 会抛出异常。这样设计也是合理得，在迭代时进行添加元素会导致各种各样的问题，在Java遍历集合中就有体现(使用了快照的方式)。 而.net的做法更加简洁 补充： 在高版本中 会有如await foreach 这是常用的异步编程，具体原理比较复杂，都是交给编译器去把异步代码变为普通代码的。 可以使用反编译工具自行查看。这时候要实现IAsyncEnumerable 接口方法"},{"title":"保护模式","date":"2022-09-12T13:12:31.000Z","url":"/2022/09/12/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/","tags":[["OS","/tags/OS/"]],"categories":[["undefined",""]],"content":" 保护模式保护模式(Protected Model ，又称PModel),是x86系列cpu的一种运行模式 事实上，x86系列cpu有五种模式：时模式（16位），保护模式（32位），IA-32e模式（64位） SMM（系统管理模式），虚拟8086模式 在这个保护模式下面，我们可以： 使用更大的32位寄存器 使用更多的内存，4gb（如果目标机器安装了足够的Ram的话） 能够执行c语言编译过来的机器码 有得必有失： 不能使用bios提供给我们的例程（各种int中断） ​ 访问磁盘，读取内存大小，从屏幕显示文字，等等需要通过BIOS中断使用的功能 没有系统调用，没有标准库，没有异常捕获，什么都没有。一切都要自己造轮子 cpu变得更加脆弱，哪怕一个轻微的bug（比如1&#x2F;0这类运算），都可以直接导致Triple Fault 保护模式下的寄存器实模式下： AX BX CX DX SI DI BP SP 保护模式下 EAX EBX ECX EDX ESI EDI EBP ESP 前面都追加了一个“E”作为前缀 当并不是所有的寄存器！ 段寄存器：CS，ES，DS，SS 依然维持原样，且大小也维持在16位 保护模式如何保护保护模式主要是对内存区域的保护 ​ 从而保障了进程（的专属内存空间）之间的安全 所以为了做到这一点，保护模式允许我们…. 对内存进行分区 对每个分区进行单独的配置 ​ 比如权限，功能，等等其它一堆配置 换言之，保护模式允许我们自己绘制一幅内存地图-更高的自由度! 内存地图CPU会照着这份内存地图来按照我们的规则去控制内存空间的访问，从而起到保护作用 ​ 一般而言，这份地图包括： ​ 内存中已经被划分的区域的位置 ​ 每个区域的种类 ​ 每个区域的权限 为了方便CUP管理，我们得需要为每个区域进行登记，比如登记在一个表格里。这样子， CPU能够通过查表十分快速了解到，我要管理得这个区域在哪里？这个区域有多大？是干什么？谁可以访问？ 用计算机的话来讲…. ​ 这些区域我们叫做段（Segment） ​ 用来做登记的表格叫做全局描述表（Gobal Descriptor Table,GDT） ​ 每一条登记叫做段描述符（Segment Descriptor ，SD） 进入保护模式 这是一幅关于各个CPU模式之间的状态转移图。包括了我们之前提到的五大模式 在这里我们重点关注实地址模式（Real-Address Model）到保护模式（Protected Model）的转换 我们发现，只需要简单的将CR0寄存器中的PE标志位拉高，便可以进去保护模式 从图中可以看出来，PE在第一位。所以我们只需要将CR0的东西和0x00000001进行与运算，然后把结果写回CR0.（是的，CR0是可以被我们用MOV指令操作的！） 进入保护模式事实上，Intel给出了十分详细的步骤 注意！在第4步，前面使用了Immediately,这就意味着MOV CR0和第四步的语句之间不能有任何的其它语句！ （事实上，在intel提供的手册中明确告诉我们，否则会出现一些随机错误）"}]